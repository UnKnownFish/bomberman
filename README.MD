Bomberman
=============================
Об игре.
------------
В данном проекте была реализована упрощённая версия игры Bomberman. Механика игры позаимствована у оригинала. Реализованы следующие игровые правила:

* в начале игры случайным образом генерируется игровое поле;
* каждый игрок может бегать по пустым клеткам и ставить бомбы;
* бомбы взрывают только деревянные блоки. Камни взрывать нельзя;
* Радиус подрыва бомбы +2 клетки от места установки бомбы (легко можно настроить в GameConfig);
* Бомба взрывается через 3 секунды после установки;
* В начале игры каждый игрок может установить только одну бомбу.  Но каждые 30 секунду количество бомб увеличивается на одну.

Вся логика работы игры реализована на серверной части. Клиент используется просто для отображения состояния игры.

Игровая архитектура
------------
Игру можно посмотреть в действии по ссылке [http://ec2-52-59-250-47.eu-central-1.compute.amazonaws.com/](http://ec2-52-59-250-47.eu-central-1.compute.amazonaws.com/)
(Ссылка не содержит рекламы или вредоносного контента)

Так как задание выполнялось для uawebchallenge/backend то было принято решение сделать всю игру полностью на сервере.
При этом на клиентскую часть сервер отдавал бы готовый snapshot игрового поля. Даже движения игроков просчитывались бы на сервере. 
Риск такого решения - плавность прорисовки игры на клиенте пострадает. Но так как задание выполняется для backend challenge 
а не для frontend challenge то такой риск считаю приемлимым. 
Для транспорта данных были реализованы REST вебсервисы а так же Websocket endpoint.

Упрощённо игровую архитектуру можно описать следующим образом:

1. Игрок создаёт новую игру;
2. Клиентская часть посылает REST запрос на сервер. Сервер обработав запрос возвращает ID игры и ID пользователя;
3. Клиентская часть соединяется с WebSocket и слушает сообщения, которые придут на топик игры (/topic/gameId);
4. Когда пришло новое сообщение клиентская часть отрисовывает игровое поле и позиции игроков на поле;
5. Игрок делает ход (Нажимает на кнопку "вниз");
6. Клиентская часть отсылает на север ID игрока и команду "вниз";
7. Сервер валидирует команду пользователя и применит её при отправке следующего PUSH сообщения на клиент.

Таким образом клиент просто отправляет команды на сервер и перерисовывается в зависимости от того что сервер пушит. Вся логика игры на сервере. 

Серверная часть
------------
Серверная часть написана на **java**. Для запуска сервера используется **Spring Boot**. Точками входа в серверную часть
являются GameRestService и CommandWsService.

**GameRestService** - REST вебсервис, который позволяет создавать новую игру, подключаться к запущеной игре, а так же 
принимать комманды игроков (эта функциональность использовалась вначале, но затем была переписана на WebSocket. 
Решил оставить для наглядности и возможно дальнейших бенчмарков)

**CommandWsService** - сервис обработки команд игроков которые приходят по сокету (система использует SockJs для фолбэка, 
поэтому сообщение всё равно будет доставлено даже если сокеты не работают как надо)
 
В классе **GameConfig** собраны все настройки игры (FPS, Bombs count etc).

Сердцем "контролирующей" прослойки игры является пакет **"com.uawebchallenge.bomberman.game.control"**.
**GameManager** - хранит ссылки на все запущенные игры и может создать и запустить новую игру.
**GameRunner** - при запуске новой игры GameRunner создаёт поток, который обрабатывает состояние игры с определённым интервалом.
По сути GameRunner контролирует игровой цикл (game loop). Частоту просчёта состояния игры (FPS) можно посмотреть в GameConfig.timeBetweenFrames.
**GameRunnable** – поток в котором запущена игра. Этот поток просчитывает новое состояние игры и отсылает его нужным клиентам.
 
Всё что касается самой игры находится в пакете **"com.uawebchallenge.bomberman.game.model"**. Классы этого пакета
представляют игровые сущности и не связаны с Spring, Websockets или ещё чем-либо.
 
Для компиляции и запуска сервера приложения вам необходимо иметь jdk и maven. 
Откройте папку bomberman.server и запустите комманду **mvn clean install** в командной строке.
Затем перейдите в папку target и выполните **java - jar bomberman.server-1.0.0-SNAPSHOT.jar**.
Сервер будет запущен на порту 9090.
 
Клиентская часть
------------
Клиентская часть написана на AngularJs. Игровое поле представляет собой обычную таблицу (table). 
Каждая ячейка таблицы соответствует игровой сетке на сервере. Когда с сервера приходит обновление - таблица перерисосывается. 
Игрок на поле отрисовывается используя абсолютное позицирование. Вот и весь клиент.... )
 
AngularJs - ужасный выбор для такого вида клиента, так как приходится отрисовывать состояние игры часто (в зависимости 
от GameConfig.timeBetweenFrames. По умолчанию 50ms - 20FPS). Занчит нужно очень часто запускать digest loop и надеяться 
что он отрисует поле быстро. React больше бы подходил для выполнения этой задачи. К сожалению мои знания в React 
оставляют желать лучшего. Чтоб оценивать время отрисовки и понимать не является ли Angular моим ботлнэком к проетку был 
прикручен digest-hub (сборщик статистики о времени отрисовки digest loop). В правом верхнем углу приложения можно увидеть 
эту статистику.
 
Для запуска клиентской части вам понадобится node.js (точнее npm).
Откройте папку bomberman.ui и выполните **npm install**. 
Далее у вас есть 2 варианта:

Либо запустить **npm run build** - тогда webpack скомпилирует готовый html, js, assets и поместит их в папку build. 
Файлы из папки build нужно поместить в любимый http сервер и настроить проксирование (чтоб запросы к контексту 
/bomberman были перенаправлены на Spring boot backend server http://localhost:9090/bomberman)

Либо запустить **npm run dev** - тогда webpack запустит Dev Server и можно будет сразу попробовать игру. 
Единственная проблема с этим подходом - websocket проксирование не работает. Но ничего страшного SockJs будет 
использовать ajax streaming и всё будет работать.
 
Выводы, проблемы и т.д
------------
В игре не реализованы боты. На это просто не хватило времени а делать ботов которые ставят бомбы под себя и упираются в 
стены просто не хотелось. Но зато в игре есть полноценный мультиплеер и если учесть что вся обработка игры происходит 
на сервере - то плавность игры более менее нормальная.

**Что сделано:**

 - Полноценная игра с UI и Backend;
 - Полноценный мультиплеер;
 - Выполнены все требования задания (кроме одного). И все настройки легко кастомизируются;
 - Высокое качество кода (если верить статическим анализаторам кода) и читаемось. Дизайн позволяет расширять игру и вносить новые фичи легко.
 
 
 **Что не сделано:**
 
 - Боты. Вообще не сделаны. Совсем (
 - Тестов маловато. Являясь фанатом TDD вынужден признать что тестов очень мало.